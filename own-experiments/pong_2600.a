    processor 6502
    include "vcs.h"
    include "macro.h"
    include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This cartridge implements a simple Pong clone in 4K.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PaddleSpriteHeight  equ 20
PaddleSpriteColor   equ #$0E

Paddle1_FixedXPos   equ 5
Paddle2_FixedXPos   equ 12

PaddleStartYPos     equ $60
BallStartXPos       equ 30
BallStartYPos       equ 160
ScreenRightEdge     equ 140

PaddleSpritePattern     equ #%00010000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

    seg.u Variables
    org $80

; Y goes from bottom to top. It refers to the lower part 
; of the paddle.
Paddle1_SpriteYPos  .byte
Paddle2_SpriteYPos  .byte

BallXPos        .byte
BallYPos        .byte
BallMovesRight      .byte

; A general purpose byte used to store the results of 
; intermediate calculations:
Temp            .byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

    seg Code
    org $f000

Start
    CLEAN_START
        
    lda #PaddleStartYPos    ; start centered
    sta Paddle1_SpriteYPos
    sta Paddle2_SpriteYPos
    lda #BallStartYPos
    sta BallYPos
    lda PaddleSpriteColor
    sta COLUP0      ; store color
    sta COLUP1
    sta COLUPF      ; ball uses the playfield color
    lda #BallStartXPos
    sta BallXPos
    lda #0
    sta BallMovesRight

NextFrame
    ; 262 scanlines in total. Use the xmcaros to simplify 
    ; the TIA line sync during VSYNC and overscan.
    VERTICAL_SYNC   ; 1 VBLANK + 3 VSYNC
    TIMER_SETUP 37  ; 37 VBLANK
    ; This idle period during VBLANK is a great place for our 
    ; sophisticated game logic.
    ; 1. position Paddle 1 horizontally...
    lda Paddle1_FixedXPos
    ldx #0  ; player object 1
    jsr PositionHoriz
    ; 2. now do the same thing for Paddle 2...
    lda Paddle2_FixedXPos
    ldx #1  ; player object 2
    jsr PositionHoriz
    ; 3. ...and the ball:
    lda BallXPos
    ldx #4  ; ball object TODO!!
    jsr PositionHoriz

    ; Note that HMOVE updates *all* sprites, so we only want to 
    ; do it once all our objects are positioned. Now is that time:
    sta WSYNC
    sta HMOVE   ; apply HMOVE to update the X position
    TIMER_WAIT
    ; Turns off the Vertical Blank signal ( = image output on)
    lda #0
    sta VBLANK
    ; The 192 visible scanlines have to be iterated through; we 
    ; cannot use the PIA timer since we need to find the YPos of 
    ; our sprite and then start drawing it there.
    ldx #192    
LVScan
    ; TODO: figure out how to draw these on the same scanline...
    jsr DrawPaddle_1_Sprite
    dex ; move on to the next scanline
    
    jsr DrawPaddle_2_Sprite
    dex ; move on to the next scanline
    
    jsr DrawBall_Sprite
    dex
    
    bne LVScan  ; repeat until 192 lines

    ; Overscan
    TIMER_SETUP 29
    ; Turns on the Vertical Blank signal ( = image output off)
    lda #2
    sta VBLANK
    ; Now we have a few clock cycles during overscan where we 
    ; can process the joystick output:
    jsr MoveJoystick
    ; ..and let the ball move:
    jsr MoveBall
    TIMER_WAIT  ; end overscan
    jmp NextFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PositionHoriz subroutine
    sta WSYNC   ; wait for the next scanline
    ; To find the rough X-position, we divide by 15.
    ; We divide by 15 since that's the number of TIA 
    ; clock cycles consumed by our instructions in the 
    ; loop below (sbc and bcs).
    ;
    ; Of course, there's no division support on the 6502 so we 
    ; need to subtract instead until A becomes negative.
    sec         ; Always set carry when subtracting.
.RoughXPosition ; The . (dot) creates a local label.
    sbc #15
    bcs .RoughXPosition ; Until A is negative
    ; The fine position can be set within -7 <-> +8 pixels.
    ; To do this, we keep the reminder from our division 
    ; and shift those bits left into the higher nibble; the HMP0 
    ; registers wants it there.
    eor #7
    asl
    asl
    asl
    asl
    sta HMP0,x      ; the fine offset..
    sta RESP0,x     ; ..and its coarse position.
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read joystick movement to control the paddle.
; Since it's Pong, we only need to care 
; about vertical movement:
MoveJoystick
; Move vertically
; (up and down are actually reversed since ypos starts at bottom)
    ldx Paddle1_SpriteYPos
    lda #%00100000  ;Up?
    bit SWCHA
    bne .SkipMoveUp
    cpx #10     ; prevent exiting the bottom of the screen
    bcc .SkipMoveUp
    dex
    dex
.SkipMoveUp
    lda #%00010000  ;Down?
    bit SWCHA 
    bne .SkipMoveDown
    cpx #170    ; prevent exiting the upper screen
    bcs .SkipMoveDown
    inx
    inx
.SkipMoveDown
    stx Paddle1_SpriteYPos
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Move the ball on each frame.
MoveBall
   ldx BallXPos
   inx
   stx BallXPos
   rts
   
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The following two subroutines encapsulate the knowledge of 
; the inputs to the common subroutine, DrawPaddleSprite.
DrawPaddle_1_Sprite subroutine
    lda Paddle1_SpriteYPos  ; input to DrawPaddleSprite
    sta Temp
    ldy #0          ; sprite 1, input to DrawPaddleSprite
    jsr DrawPaddleSprite
    rts
    
DrawPaddle_2_Sprite subroutine
    lda Paddle2_SpriteYPos  ; input to DrawPaddleSprite
    sta Temp
    ldy #1          ; sprite 2, input to DrawPaddleSprite
    jsr DrawPaddleSprite
    rts

DrawBall_Sprite subroutine
    txa         ; current scanline
    cmp BallYPos
    beq .DoDrawBall
    lda #0
    sta WSYNC   ; sync w/ scanline
    sta ENABL
    rts
.DoDrawBall
    lda #2      ; enable the ball
    sta WSYNC   ; sync w/ scanline
    sta ENABL
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Draws the paddle sprite if we're at its scanlines.
; This subroutine is reused to draw both player 1 & 2 using 
; the following registers:
;
;   X    => contains the current scanline
;   Y    => contains the player sprite, 0 for player 1, 1 for player 2
;   Temp => contains the paddle Y-position.
;
DrawPaddleSprite subroutine
    ; are we at the scanline where YPos for our sprite starts?
    txa         ; let A contain the current scanline
    sec         ; ðŸ’¡ always set carry for subtract
    sbc Temp    
    cmp #PaddleSpriteHeight 
    bcc .MaybeDrawSprite ; yes, skip over the next instruction
    lda #0          ; no, so disable all sprites
    ; note that we always execute the following segment
    ; its behaviour depends on what's stored in A:
    ;  - either the lookup index for the sprite byte, or
    ;  - zero to clear the sprite register when outside the relevant scanline
.MaybeDrawSprite
    cmp #0
    beq .DoDrawSprite ; let A remain as 0 (zero) to disable the sprite
    lda PaddleSpritePattern
.DoDrawSprite
    sta WSYNC   ; sync w/ scanline
    ; The following works since GRP1 follows immediately after 
    ; GRP0 in the TIA memory map:
    sta GRP0,y  ; store the bitmap for player 1 _or_ 2 (Y-offset)
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pad the cartridge to 4K

    org $fffc
    .word Start ; reset vector
    .word Start ; BRK vector