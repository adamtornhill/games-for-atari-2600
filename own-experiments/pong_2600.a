    processor 6502
    include "vcs.h"
    include "macro.h"
    include "xmacro.h"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This cartridge implements a simple Pong clone in 4K.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PaddleSpriteHeight  equ 20
PaddleSpriteColor   equ #$0E
PaddleFixedXPos     equ 5
PaddleStartYPos     equ $60

PaddleSpritePattern     equ #%00010000

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

    seg.u Variables
    org $80

; Y goes from bottom to top. It refers to the lower part 
; of the paddle.
PaddleSpriteYPos    .byte
; Keep track of how many sprite line we have 
; drawn, starting at PaddleSpriteYPos.
PaddleLinesDrawn    .byte

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment

    seg Code
    org $f000

Start
    CLEAN_START
        
    lda #PaddleStartYPos    ; start centered
    sta PaddleSpriteYPos
    lda PaddleSpriteColor
    sta COLUP0  ; store color

NextFrame
    ; 262 scanlines in total. Use the xmcaros to simplify 
    ; the TIA line sync during VSYNC and overscan.
    VERTICAL_SYNC   ; 1 VBLANK + 3 VSYNC
    TIMER_SETUP 37  ; 37 VBLANK
    ; This idle period during VBLANK is a great place for our 
    ; sophisticated game logic.
    lda #0
    sta PaddleLinesDrawn    ; start over for each frame
    lda PaddleFixedXPos
    ldx #0  ; player object 1
    jsr PositionHoriz
    sta WSYNC
    sta HMOVE   ; apply HMOVE to update the X position
    TIMER_WAIT
    ; Turns off the Vertical Blank signal ( = image output on)
    lda #0
    sta VBLANK
    ; The 192 visible scanlines have to be iterated through; we 
    ; cannot use the PIA timer since we need to find the YPos of 
    ; our sprite and then start drawing it there.
    ldx #192    
LVScan
    jsr DrawPaddleSprite
    dex ; move on to the next scanline
    
    bne LVScan  ; repeat until 192 lines

    ; Overscan
    TIMER_SETUP 29
    ; Turns on the Vertical Blank signal ( = image output off)
    lda #2
    sta VBLANK
    ; Now we have a few clock cycles during overscan where we 
    ; can process the joystick output:
    jsr MoveJoystick
    TIMER_WAIT  ; end overscan
    jmp NextFrame

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PositionHoriz subroutine
    sta WSYNC   ; wait for the next scanline
    ; To find the rough X-position, we divide by 15.
    ; We divide by 15 since that's the number of TIA 
    ; clock cycles consumed by our instructions in the 
    ; loop below (sbc and bcs).
    ;
    ; Of course, there's no division support on the 6502 so we 
    ; need to subtract instead until A becomes negative.
    sec         ; Always set carry when subtracting.
.RoughXPosition ; The . (dot) creates a local label.
    sbc #15
    bcs .RoughXPosition ; Until A is negative
    ; The fine position can be set within -7 <-> +8 pixels.
    ; To do this, we keep the reminder from our division 
    ; and shift those bits left into the higher nibble; the HMP0 
    ; registers wants it there.
    eor #7
    asl
    asl
    asl
    asl
    sta HMP0,x      ; the fine offset..
    sta RESP0,x     ; ..and its coarse position.
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Read joystick movement to control the paddle.
; Since it's Pong, we only need to care 
; about vertical movement:
MoveJoystick
; Move vertically
; (up and down are actually reversed since ypos starts at bottom)
    ldx PaddleSpriteYPos
    lda #%00100000  ;Up?
    bit SWCHA
    bne .SkipMoveUp
    cpx #10     ; prevent exiting the bottom of the screen
    bcc .SkipMoveUp
    dex
    dex
.SkipMoveUp
    lda #%00010000  ;Down?
    bit SWCHA 
    bne .SkipMoveDown
    cpx #170    ; prevent exiting the upper screen
    bcs .SkipMoveDown
    inx
    inx
.SkipMoveDown
    stx PaddleSpriteYPos
    rts

DrawPaddleSprite subroutine
    ; are we at the scanline where YPos for our sprite starts?
    txa         ; let A contain the current scanline
    sec         ; ðŸ’¡ always set carry for subtract
    sbc PaddleSpriteYPos    
    cmp #PaddleSpriteHeight 
    bcc .MaybeDrawSprite ; yes, skip over the next instruction
    lda #0          ; no, so disable all sprites
    ; note that we always execute the following segment
    ; its behaviour depends on what's stored in A:
    ;  - either the lookup index for the sprite byte, or
    ;  - zero to clear the sprite register when outside the relevant scanline
.MaybeDrawSprite
    cmp #0
    beq .DoDrawSprite ; let A remain as 0 (zero) to disable the sprite
    lda PaddleSpritePattern;PaddleSprite,y  ; lookup color
.DoDrawSprite
    sta WSYNC   ; sync w/ scanline
    sta GRP0    ; store bitmap
    rts

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pad the cartridge to 4K

    org $fffc
    .word Start ; reset vector
    .word Start ; BRK vector